<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小贤的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-29T14:45:20.016Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zexian Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql复制</title>
    <link href="http://yoursite.com/2020/04/29/mysqlBackUp/"/>
    <id>http://yoursite.com/2020/04/29/mysqlBackUp/</id>
    <published>2020-04-29T14:20:00.000Z</published>
    <updated>2020-04-29T14:45:20.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h2><p>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。</p><p>mysql支持两种复制方式：<strong>基于行的复制、基于语句的复制</strong></p><p>两种方式都是通过在主库上面记录二进制日志文件，然后在备库中重放日志的方式来实现异步的数据复制。这意味着在同一个时间点备库上的数据可能与主库不一致，并且无法保证主备之间的延迟。</p><p>引出的问题：</p><p>​    复制通常不会增加主库的开销，主要是启用二进制日志带来的开销，但是出于备份或者及时从崩溃中恢复的目的这点开销是必须的。除此之外每个备库会对主库增加一些负载（网络I/O的开销），尤其是当备库请求从主库读取旧的二进制日志文件时，可能会造成更高的I/O开销。</p><h2 id="复制解决的问题"><a href="#复制解决的问题" class="headerlink" title="复制解决的问题"></a>复制解决的问题</h2><ul><li>数据分布<ul><li>构建不同的数据中心，在不同的地理位置分布数据备份。</li></ul></li><li>负载均衡<ul><li>通过mysql复制可以将读操作分布到多个服务器上，实现对读密集型应用的优化并且实现很方便，通过简单的代码修改就能实现基本的负载均衡。小规模的应用可以简单的对机器名做硬编码或者使用dns轮询（将一个机器名指向多个ip地址），linux虚拟服务器（linux virtual server LVS）也能很好的工作。</li></ul></li><li>备份<ul><li>数据备份的补充。</li></ul></li><li>高可用和故障切换<ul><li>复制能够帮助应用程序避免mysql单点失败。一个包含复制的设计良好的故障切换系统能够显著的缩短宕机时间。</li></ul></li><li>mysql升级测试<ul><li>这种做法比较普遍，使用一个更高版本的mysql作为备库，保证在升级实例前查询能够在备库按照预期执行。</li></ul></li></ul><h2 id="复制如何工作"><a href="#复制如何工作" class="headerlink" title="复制如何工作"></a>复制如何工作</h2><p>复制有三个步骤：</p><ul><li><p>在主库上把数据更改记录到二进制日志（Binary Log)中。</p></li><li><p>备库将主库的日志复制到自己的中继日志（Relay Log）中。</p></li><li><p>备库读取中继日志中的事件，将其重放到备库数据之上。</p></li><li><p>如下图：</p><ul><li><img src="/2020/04/29/mysqlBackUp/mysqlBackup/image-20200426234938957.png" alt="image-20200426234938957"></li></ul></li></ul><p>步骤解读：</p><p>1）mysql会按事务提交的顺序而非每条语句执行顺序来记录二进制日志。在记录二进制日志后，主库会告诉存储索引可以提交事务了。</p><p>2）备库启动一个I/O线程跟主库建立一个普通的客户端连接，然后在主库上启动一个特殊的二进制转储线程（binlog dump），这个二进制转储线程会读取主库上二进制日志中的事件。它不会对事件进行轮询，如果该线程追赶上了主库它将进入睡眠状态，知道主库发送信号通知其有新的事件产生时才会被唤醒，备库I/O线程会将接收到的事件记录到中继文件中。</p><p>3）备库的sql线程执行最后一步，该线程从中继日志中读取事件并在备库中执行，从而实现备库数据的更新。中继日志通常在系统的缓存中所以开销很低。</p><p>这种复制架构使得获取事件和重放事件实现了解耦。允许这两个过程异步进行。但是它也有缺点，因为只有一个sql线程来重放中继日志中的事件所以它会是一个性能的瓶颈。</p><h2 id="配置复制"><a href="#配置复制" class="headerlink" title="配置复制"></a>配置复制</h2><p>分为三步</p><p>1）在每台服务器上创建复制账号。</p><p>2）配置主库和备库。</p><p>3）通知备库连接到主库并从主库复制数据。</p><h2 id="复制的原理"><a href="#复制的原理" class="headerlink" title="复制的原理"></a>复制的原理</h2><ul><li>基于行复制：将实际的数据记录在二进制日志中，最大的好处是可以正确的复制每一行。</li><li>基于语句复制:语句的复制也称为<strong>逻辑复制</strong>主库会记录那些造成数据更改的查询，备库读取并重放这些事件时，实际上是把在主库上面执行过的sql再执行一遍。</li><li>两种方式哪种更优？<ul><li>具体问题具体分析。</li></ul></li></ul><h2 id="mysql复制的高级特性"><a href="#mysql复制的高级特性" class="headerlink" title="mysql复制的高级特性"></a>mysql复制的高级特性</h2><ul><li>mysql5.5后复制的性能显著提高。5.6后将包含这些特性：<ul><li>增加多线程并行复制减少单线程复制的瓶颈。</li><li>半同步复制</li><li>复制心跳</li></ul></li></ul><h2 id="其他复制技术"><a href="#其他复制技术" class="headerlink" title="其他复制技术"></a>其他复制技术</h2><ul><li>PerconaXtraDb Cluster的同步复制</li><li>Tungsten Replicator</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>mysql复制是其内建功能中的“瑞士军刀”，显著的增加了mysql的功能和可用性。这也是mysql这么快流行的原因。</p><ul><li>配置、监控、管理和优化服务器本身是不具备这些功能的，可以尝试引入第三方工具来帮助做这些工作，例如 Percona Toolkit和Percona XtraBackup</li><li>确保主库和备库相同<ul><li>使用Percona Toolkit中的pt-table-checksum以确保备库是主库的真实拷贝</li><li>监控复制以确定其正在运行并且没有落后于主库。</li><li>理解复制的异步本质，并且设计你的应用以避免或者容忍从备库读取脏数据。</li><li>在一个复制拓扑中不要写入超过一个服务器，把备库配置为只读，并降低权限以阻止对数据的改变。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      基于《高性能mysql》第十章复制的杂记。
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>lua+kafka+nginx采集nginx日志</title>
    <link href="http://yoursite.com/2019/01/20/lua+kafka+nginx%E9%87%87%E9%9B%86nginx%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2019/01/20/lua+kafka+nginx采集nginx日志/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2020-04-29T13:36:55.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>解决nginx的访问日志过大文件占用磁盘，文件分割归档、日志实时性的弊端。</li></ul><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><ul><li>openresty(lua) + kafka组合实现一个日志采集的轻量级架构</li><li>大致架构如下：<ul><li><img src="/2019/01/20/lua+kafka+nginx采集nginx日志/architecture.png" alt="架构图"></li></ul></li></ul><p>说明:</p><ul><li>线上请求打向nginx后，使用openresty(lua)完成日志整理:如统一日志格式,获取关键的请求参数组装成写入kafka的message。</li></ul><h2 id="使用的组件和技术"><a href="#使用的组件和技术" class="headerlink" title="使用的组件和技术"></a>使用的组件和技术</h2><ul><li>docker:容器化技术</li><li>openresty:将Nginx转变为完整的可编写脚本的Web平台</li><li>lua_resty_kafka:基于cosocket API的Openresty的Lua kafka客户端驱动程序</li><li>kafka：分布式消息队列</li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ul><li><p>项目结构:</p><ul><li><img src="/2019/01/20/lua+kafka+nginx采集nginx日志/project.png" alt="项目结构图"></li></ul></li><li><p>准备nginx.conf</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> logs/error.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$time_iso8601</span>\t<span class="variable">$request</span>\t<span class="variable">$remote_addr</span>\t<span class="variable">$http_user_agent</span>\t<span class="variable">$http_referer</span>\t'</span></span><br><span class="line">                    <span class="string">'<span class="variable">$request_body</span>'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">sendfile</span>            <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>         <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>   <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">types_hash_max_size</span> <span class="number">2048</span>;</span><br><span class="line">    <span class="attribute">default_type</span>        application/octet-stream;</span><br><span class="line">    <span class="attribute">lua_package_path</span> <span class="string">"/opt/openresty/lualib/kafka/?.lua;;"</span>;    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">server_name</span>  _;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span>         /opt/openresty/nginx/html;</span><br><span class="line">        <span class="attribute">lua_need_request_body</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">            <span class="attribute">expires</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="attribute">content_by_lua_file</span> /opt/openresty/nginx/writeToKafka.lua;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">            <span class="attribute">location</span> = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">            <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写lua脚本处理日志</p><ul><li>注意:将<code>borker_list</code>和<code>KAFKA_TOPIC_KEY</code>替换为你自己的kafka地址和主题。<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--引入所有api  </span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">"cjson"</span>  </span><br><span class="line"><span class="keyword">local</span> producer = <span class="built_in">require</span> <span class="string">"resty.kafka.producer"</span>  </span><br><span class="line"><span class="comment">-- 定义kafka broker地址  </span></span><br><span class="line"><span class="keyword">local</span> broker_list =  &#123;&#123; host = <span class="string">"xx.xx.xx.xx"</span>, port = <span class="number">9092</span> &#125;,&#125;  </span><br><span class="line"><span class="comment">-- 定义message便于日志数据整理收集  </span></span><br><span class="line"><span class="keyword">local</span> message = <span class="string">""</span></span><br><span class="line"><span class="keyword">local</span> separator = <span class="string">""</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = (<span class="literal">nil</span> == ngx.var.uri) <span class="keyword">and</span> <span class="string">"-"</span> <span class="keyword">or</span> ngx.var.uri</span><br><span class="line"><span class="keyword">local</span> query_string = (<span class="literal">nil</span> == ngx.var.query_string) <span class="keyword">and</span> <span class="string">"-"</span> <span class="keyword">or</span> ngx.var.query_string</span><br><span class="line"><span class="keyword">local</span> client_ip = ngx.var.remote_addr  </span><br><span class="line"><span class="keyword">local</span> referer = (<span class="literal">nil</span> == ngx.var.http_referer) <span class="keyword">and</span> <span class="string">"-"</span> <span class="keyword">or</span> ngx.var.http_referer</span><br><span class="line"><span class="keyword">local</span> user_agent = ngx.var.http_user_agent  </span><br><span class="line"><span class="keyword">local</span> receiveTime = ngx.var.time_iso8601</span><br><span class="line"><span class="keyword">local</span> request_method = ngx.var.request_method</span><br><span class="line"><span class="keyword">local</span> cookie = (<span class="literal">nil</span> == ngx.var.http_cookie) <span class="keyword">and</span> <span class="string">"-"</span> <span class="keyword">or</span> ngx.var.http_cookie  </span><br><span class="line"><span class="comment">-- 拼接massage</span></span><br><span class="line">message = receiveTime..separator..request_method..separator..<span class="built_in">path</span>..separator..query_string..separator..client_ip..separator..user_agent..separator..referer..separator..cookie</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 新增写入kafka错误日志记录</span></span><br><span class="line"><span class="keyword">local</span> error_handle = <span class="function"><span class="keyword">function</span> <span class="params">(topic, partition_id, queue, index, err, retryalbe)</span></span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"origin send message:"</span>, message)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 定义kafka异步生产者  </span></span><br><span class="line"><span class="keyword">local</span> bp = producer:new(broker_list, &#123; producer_type = <span class="string">"async"</span>, error_handle = error_handle &#125;)  </span><br><span class="line"><span class="comment">-- 发送日志消息,send第二个参数key,用于kafka路由控制:  </span></span><br><span class="line"><span class="comment">-- key为nill(空)时，一段时间向同一partition写入数据  </span></span><br><span class="line"><span class="comment">-- 指定key，按照key的hash写入到对应的partition  </span></span><br><span class="line">bp:send(<span class="string">"$&#123;KAFKA_TOPIC_KEY&#125;"</span>, <span class="literal">nil</span>, message)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>编写镜像文件Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MAINTAINER</span> 阿贤 &lt;jsonlisky@gmail.com&gt;</span><br><span class="line"><span class="keyword">RUN</span> mkdir /opt/nginx;</span><br><span class="line">ADD ./master.zip /opt/nginx/</span><br><span class="line">RUN yum install -y \</span><br><span class="line">  readline-devel \</span><br><span class="line">  pcre-devel \</span><br><span class="line">  openssl-devel \</span><br><span class="line">  gcc \</span><br><span class="line">  zip \</span><br><span class="line">  unzip \</span><br><span class="line">  wget \</span><br><span class="line">  perl \</span><br><span class="line">  make;</span><br><span class="line">RUN  cd /opt/nginx &amp;&amp; wget https://openresty.org/download/openresty-1.9.7.4.tar.gz;</span><br><span class="line">RUN  cd /opt/nginx &amp;&amp; tar -xzf /opt/nginx/openresty-1.9.7.4.tar.gz;</span><br><span class="line">RUN  cd /opt/nginx/openresty-1.9.7.4 &amp;&amp; ./configure --prefix=/opt/openresty --with-luajit --without-http_redis2_module --with-http_iconv_module &amp;&amp; gmake &amp;&amp; gmake install;</span><br><span class="line">RUN  unzip /opt/nginx/master.zip -d /opt/nginx/;</span><br><span class="line">RUN  mkdir /opt/openresty/lualib/kafka;</span><br><span class="line">RUN  cp -rf /opt/nginx/lua-resty-kafka-master/lib/resty /opt/openresty/lualib/kafka/;</span><br><span class="line">RUN echo "install  complete!"</span><br><span class="line">ADD ./nginx.conf /opt/openresty/nginx/conf/</span><br><span class="line">ADD ./writeToKafka.lua  /opt/openresty/nginx/</span><br><span class="line">RUN ln -sf /dev/stdout /opt/openresty/nginx/logs/access.log \</span><br><span class="line">&amp;&amp; ln -sf /dev/stderr /opt/openresty/nginx/logs/error.log</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD ["/opt/openresty/nginx/sbin/nginx", "-g", "daemon off;"]</span><br></pre></td></tr></table></figure></li><li><p>进入到Dockerfile目录执行构建镜像命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker build -t openresty-nginx .</span><br></pre></td></tr></table></figure></li><li><p>运行容器(对外暴露8080端口)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 openresty-nginx</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试校验"><a href="#测试校验" class="headerlink" title="测试校验"></a>测试校验</h2><ul><li><p>简单的curl查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:8080</span><br></pre></td></tr></table></figure></li><li><p>使用kafka消费者命令消费查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server --.--.--.--:9092 --topic topicName  --from-beginning</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      这篇文章主要介绍lua+kafka+nginx采集日志的方案。。
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq延迟队列的实践</title>
    <link href="http://yoursite.com/2018/11/04/rabbitmq%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/11/04/rabbitmq延迟队列的实践/</id>
    <published>2018-11-03T16:00:00.000Z</published>
    <updated>2020-04-29T13:36:55.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="延迟队列使用场景"><a href="#延迟队列使用场景" class="headerlink" title="延迟队列使用场景"></a>延迟队列使用场景</h2><ul><li>12306平台订票，旅客提交订单后需要在30分钟内付款完成订单，否则要将锁定的座位解锁让其它旅客重新购买。</li><li>客户购买商品后,系统根据购买信息延迟下发商品满意度的问卷给客户。</li></ul><h2 id="rabbitmq延迟队列实现方法"><a href="#rabbitmq延迟队列实现方法" class="headerlink" title="rabbitmq延迟队列实现方法"></a>rabbitmq延迟队列实现方法</h2><ul><li>rabbitmq官方博客介绍的使用延迟队列插件的方式来实现延迟队列。</li><li>rabbitmq官方扩展中介绍的TTL (time to live) + DLX(Dead Letter Exchanges)的特性结合也可以实现延迟队列。</li></ul><h3 id="安装插件的方式实现"><a href="#安装插件的方式实现" class="headerlink" title="安装插件的方式实现"></a>安装插件的方式实现</h3><ul><li>进入<a href="http://www.rabbitmq.com/community-plugins.html" target="_blank" rel="noopener">官方社区插件下载页</a>找到<code>rabbitmq_delayed_message_exchange</code>下载适用于RabbitMQ安装的相应.ez文件。将插件复制到RabbitMQ的插件文件夹中</li><li><p>进入rabbitmq的sbin目录下执行以下命令启用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure></li><li><p>声明一个exchange</p><ul><li><p>通过代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(&quot;x-delayed-type&quot;, &quot;direct&quot;);</span><br><span class="line">channel.exchangeDeclare(&quot;my-exchange&quot;, &quot;x-delayed-message&quot;, true, false, args);//设置类型为“x-delayed-message”</span><br></pre></td></tr></table></figure></li><li><p>通过web管理界面配置exchange也可以</p></li></ul></li><li>新增一个队列<code>my-delay-queue</code>将<code>my-exchange</code>绑定到该队列上面</li><li><p>发布一个延迟消息</p><ul><li>发布延迟队列的配置代码需要指定<code>x-delay</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte[] messageBodyBytes = &quot;delayed payload&quot;.getBytes();</span><br><span class="line">AMQP.BasicProperties.Builder props = new AMQP.BasicProperties.Builder();</span><br><span class="line">headers = new HashMap&lt;String, Object&gt;();</span><br><span class="line">headers.put(&quot;x-delay&quot;, 5000);//延迟5秒</span><br><span class="line">props.headers(headers);</span><br><span class="line">channel.basicPublish(&quot;my-exchange&quot;, &quot;&quot;, props.build(), messageBodyBytes);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动一个消费者消费队列<code>my-delay-queue</code>验证</p></li></ul><h3 id="TTL-DLX的方式实现"><a href="#TTL-DLX的方式实现" class="headerlink" title="TTL + DLX的方式实现"></a>TTL + DLX的方式实现</h3><ul><li><p>简要的流程图</p><ul><li><img src="/2018/11/04/rabbitmq延迟队列的实践/message.png" alt="消息轮转图"></li></ul></li><li><p>根据单条消息自定义延迟的方式(<strong>注意:如果前一条数据设置的超时时间大于后面的数据超时时间，那么前一条必须变更为死信后，后面的消息才会变更为死信。。相当恶心</strong>)</p><ul><li>定义cache_exchange、定义cache_queue队列指定参数x-dead-letter-exchange为delay_exchange,该参数的含义是如果队列中有死信消息则往<code>delay_exchange</code>发，最后将定义cache_exchange绑定到cache_queue</li><li>发送时指定单条消息的失效时间，失效时间一过消息将变为死信<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte[] messageBodyBytes = &quot;Hello, world!&quot;.getBytes();</span><br><span class="line">AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()</span><br><span class="line">                                 .expiration(&quot;60000&quot;)</span><br><span class="line">                                 .build();</span><br><span class="line">channel.basicPublish(&quot;cache_exchange&quot;, &quot;delay&quot;, properties, messageBodyBytes);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>根据队列定义延迟的方式</p><ul><li>创建cache_exchange、创建cache_queue队列指定参数x-message-ttl为60000，最后将定义cache_exchange绑定到cache_queue(创建可以通过web管理界面进行)</li><li><p>通过代码定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map &lt;String，Object&gt; args = new HashMap &lt;String，Object&gt;（）;</span><br><span class="line">args.put（“x-message-ttl”，60000）;</span><br><span class="line">channel.queueDeclare（“myqueue”，false，false，false，args）;</span><br></pre></td></tr></table></figure></li><li><p>经过如上配置发送往cache_exchange转发到cache_queue的消息60s后将会变为死信。</p></li></ul></li><li><p>cache_queue中的死信会根据x-dead-letter-exchange的参数配置往delay_exchange发送。</p></li><li>最后消费delay_queue队列中的消息进行业务处理。delay_queue中的消息是经过延迟后获得的消息。</li></ul><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li>启用延迟队列插件未生效的原因： Changes will take effect at broker restart;</li><li>解决办法:重启rabbitmq服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br><span class="line">systemctl restart rabbitmq-server.service</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.rabbitmq.com/ttl.html" target="_blank" rel="noopener">Time-To-Live Extensions</a></li><li><a href="https://www.rabbitmq.com/dlx.html" target="_blank" rel="noopener">Dead Letter Exchanges</a></li><li><a href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/" target="_blank" rel="noopener">Scheduling Messages with RabbitMQ</a></li></ul>]]></content>
    
    <summary type="html">
    
      这篇文章主要介绍当业务中碰到需要延时处理的场景时如何使用rabbitmq实现延迟队列来解决问题。
    
    </summary>
    
    
      <category term="rabbitmq" scheme="http://yoursite.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>git使用入门</title>
    <link href="http://yoursite.com/2018/09/28/git%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/09/28/git使用入门/</id>
    <published>2018-09-27T18:30:18.000Z</published>
    <updated>2020-04-29T13:36:55.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h2><ul><li>分布式版本控制系统</li><li>特点：<ul><li>每个开发者的本地都有一份完整的版本库</li><li>开发者可以在不联网的情况下随时随地提交自己的代码到本地仓库</li><li>开发者可以在不同的分支上并行开发最后再合并</li><li>本地的仓库push到远程仓库（服务器仓库）后开发者可共享远程仓库代码</li></ul></li></ul><h2 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h2><ul><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="noopener">参考安装</a></li></ul><h2 id="创建本地库"><a href="#创建本地库" class="headerlink" title="创建本地库"></a>创建本地库</h2><ul><li><p>创建一个文件夹</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir  learngit</span><br></pre></td></tr></table></figure></li><li><p>进入文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd  learngit</span><br></pre></td></tr></table></figure></li><li><p>初始化一个git仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>命令截图<img src="/2018/09/28/git使用入门/status.png" alt="仓库状态图"></p><ul><li>没有初始化一个git仓库前用git status查看会提示“not a git repository”是没有master标识的</li></ul></li></ul><h2 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h2><ul><li><p>进入本地的版本库主目录执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><ul><li><img src="/2018/09/28/git使用入门/remoteStatus.png" alt="仓库状态图"><br>没有提示证明未关联远程仓库</li></ul></li><li><p>将本地库与远程库关联</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin [giturl]</span><br></pre></td></tr></table></figure></li><li><p>关联后本地仓库可以将本地的代码push到远程仓库或fetch远程仓库代码到本地实现和其他开发者交换代码</p><ul><li>关联后<br><img src="/2018/09/28/git使用入门/conectStatus.png" alt="关联后截图"></li></ul></li><li>从远程仓库克隆到本地也可以实现关联远程仓库<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone [giturl]</span><br><span class="line">git clone https://username:password@xxxxxx.git</span><br></pre></td></tr></table></figure></li></ul><h2 id="git工作区和暂存区"><a href="#git工作区和暂存区" class="headerlink" title="git工作区和暂存区"></a>git工作区和暂存区</h2><ul><li>工作区（Working Directory）开发者本地可以看到的git目录</li><li>暂存区（Stage）可以理解为购物车，提交（commit）到本地仓库可以理解为付款</li><li>工作区暂存区关系<ul><li><img src="/2018/09/28/git使用入门/stage.jpg" alt="image"></li><li>第一步是用git add把修改文件或新增文件（未追踪）添加到暂存区；</li><li>第二步是用git commit提交暂存区内容到当前分支(HEAD指针指向的分支)。</li></ul></li></ul><h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><ul><li><p>查看工作区和暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>查看修改内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff filename</span><br></pre></td></tr></table></figure></li></ul><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul><li><p>查看历史提交记录%h(提交对象的简单哈希值)%s（提交说明）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=format:"%h %s" --graph</span><br></pre></td></tr></table></figure></li><li><p>回退到对应的提交节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure></li></ul><h2 id="远程版本库回退"><a href="#远程版本库回退" class="headerlink" title="远程版本库回退"></a>远程版本库回退</h2><ul><li>操作需慎重，因为远程仓库会影响到整个team</li><li><p>删除最后一次提交</p><p>1.使用revert历史记录出现放弃的提交记录</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>2.使用reset历史记录中不会出现放弃的提交记录</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">git push origin master -f</span><br></pre></td></tr></table></figure></li></ul><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><ul><li><p>查看本地当前分支</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>查看远程库分支</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch –r</span><br></pre></td></tr></table></figure></li><li><p>创建分支</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch branchname</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout branchname</span><br></pre></td></tr></table></figure></li><li><p>合并分支</p><ul><li><p>查看分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>合并分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge branch-name</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d branch-name</span><br></pre></td></tr></table></figure></li><li><p>删除远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -r -d origin/branch-name</span><br><span class="line">git push origin :branch-name</span><br></pre></td></tr></table></figure></li><li><p>批量删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch |grep 'branchName' |xargs git branch -D</span><br></pre></td></tr></table></figure></li><li><p>解决合并冲突 </p><ul><li>执行合并<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge feature1</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看未合并的冲突文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>根据提示找到未自动合并的文件（unmerged）进行冲突处理</p></li><li>解决冲突后通过下面的命令来标记文件已解决（添加到暂存区）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add unmergedfile</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "merge detail"</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>分支策略</p><ul><li>master稳定的，仅用来发布新版本</li><li>develop分支干活</li><li>开发人员从develop分支再新开分支干活，完成后再merge回develop分支</li></ul></li><li><p>多人协作</p><ul><li><p>当需要和其他开发者交换代码时，推送（push）代码到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin branch-name</span><br></pre></td></tr></table></figure></li><li><p>推送失败的话证明远程分支比本地更新，需要先拉取（pull) </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin branch-name</span><br></pre></td></tr></table></figure><p>如果合并有冲突，则解决冲突，并在本地提交。再推送</p></li><li><p>推送失败还可以先获取（fetch），再对比分支不同，再合并（merge）,建议使用因为它比pull更安全</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin branch-name</span><br><span class="line">git diff branch-name</span><br><span class="line">git merge branch-name</span><br></pre></td></tr></table></figure></li><li><p>清除本地与git origin没对应的分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch -p</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="git-生成ssh-key"><a href="#git-生成ssh-key" class="headerlink" title="git 生成ssh key"></a>git 生成ssh key</h2><ul><li><p>生成RSA key 过程 </p><ul><li><p>在指定的用户目录下，右键打开git bash 执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent bash</span><br></pre></td></tr></table></figure></li><li><p>生成RSA密钥，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C jsonlisky@gmail.com</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      这篇文章主要介绍git的简单使用以及常用的git命令。
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
